// Выполнил Пуголовок А.С., группа в3530904/80330

// Задание 8
// Надо реализовать метод, который принимает на вход String, удаляет рядом стоящие парные буквы
// и возвращает остаток. Примеры ожидаемого поведения программы:
//"aab" -> "b", "aabb" -> "", "abfbaf" -> "abfbaf”, "abccbaf" -> "f" Реализовать метод и описать
// его алгоритмическую сложность. Напишите junit-тесты.

// Оценка алгоритмической сложности:
// Вычислительная обработка производится в методе deleteCouple(),
// который имеет один цикл for c количеством итераций, равном начальному количеству символов,
// уменьшенному на 1.
// Внутренние циклы отсутствуют, поэтому сложность можно оценить как n.
// Однако ещё необходимо учесть рекурсивные вызовы этого же метода,
// максимальное количество которых может составить n/2.
// Т.е. в общем виде сложность можно представить выражением n*(n-2)*(n-2)*...*(n-2),
// где количество указанных в скобках множителей составит n/2.
// Поэтому алгоритмеческую сложность можно оценить как
// квадратный корень из (n в степени n).

class DeleteCoupleLetter {

    private String word; // это поле будет обрабатываться и изменяться в методе deleteCouple()
    private String wordStart; // это поле только для вывода результата через стрелочку

    public void setWord(String word) { // присвоение значения обоим полям
        this.word = word;
        wordStart = word;
    }

    public void deleteCouple() {

        String innerWord = ""; // внутреннее поле метода для промежуточных значений
        boolean wasDelete = false; // логическая переменная, указывающая необходимость повторного выполнения метода

        for (int i = 0; i < word.length() - 1; i++) // цикл до < length() - 1, т.к. в сравнении используется i + 1
        {
            if (word.charAt(i) != word.charAt(i + 1)) // сравнение текущего и следующего символа
            {   // если они не совпадают
                innerWord = innerWord + word.charAt(i); // то во внутренне поле вписываем первый символ из пары сравнения
                if (i == word.length() - 2) // если предпоследний и последний символы не совпали,
                {
                    innerWord = innerWord + word.charAt(i + 1); // то берём и последний (т.к. проверок больше не будет)
                }
            }
            else // если два проверяемых символа совпали
            {
                if (i == word.length() - 3) // проверяем, чтоб не потерять последний символ, если два символа перед ним удалятся
                {
                    innerWord = innerWord + word.charAt(i + 2);
                }
                wasDelete = true; // логическая переменная теперь укажет на необходимость повторной проверки
                i++;
            }
        }

        if (wasDelete == true) // если нужна повторная проверка (были два подряд идущих одинаковых символа)
        {
            word = innerWord; // изменяем значение поля, присваивая ему обработанное внутреннее
            deleteCouple(); // повторно вызываем метод
        }
        else // если удаления повторяющихся символом не было
        {
            System.out.println(wordStart + " -> " + word); // выводим в консоль результат.
        }
    }
}

public class Task8 {
    public static void main(String[] args) {

        String word = "feabbaekddcwwx"; // набор букв для обработки

        DeleteCoupleLetter obj = new DeleteCoupleLetter();

        obj.setWord(word);

        obj.deleteCouple(); // вызов метода, в котором производится обработка
    }
}
